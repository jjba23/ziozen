* ZZSpec

#+begin_html
<div>
<img src="https://img.shields.io/badge/Scala-2.13.14-red?style=plastic"/>
<img src="https://img.shields.io/badge/ZIO-2.1.9-red?style=plastic"/>
</div>
#+end_html

A Scala library with great ZIO integration to help you easily write high-level integration/black box tests.
ZZSpec tests help you grow your confidence in the correctness of software.

**Why ?** Testing at a high level  means freedom of implementation and refactoring.

This is something all engineers love üíò.

** Installing

You can install ~zzspec~ just like any other Maven/Nexus package, by adding it as dependency to your project:
#+begin_src scala
  libraryDependencies += ("zzspec" %% "zzspec" % "0.7.8") // or newer
#+end_src

ZZSpec will also pull some libraries with it, including ZIO, Circe and testcontainers.

Checkout the artifacts, which are hosted right here, on GitHub : https://github.com/jjba23/zzspec/packages/2255278 .

*** Getting started

To get started using ZZSpec, a good place to look is the integration tests of ZZSpec itself.

See the PostgreSQL spec [[./zzspec/src/test/scala/postgresqltest/PostgreSQLSpec.scala][here]].

See the OpenSearch spec [[./zzspec/src/test/scala/opensearchtest/OpensearchSpec.scala][here]].

See the Kafka spec [[./zzspec/src/test/scala/kafkatest/KafkaSpec.scala][here]].

See the MockServer spec [[./zzspec/src/test/scala/mockservertest/MockServerSpec.scala][here]].


#+begin_html
<img src="./resources/zzspec-ai.webp"/>
#+end_html


** Status of zzspec

Currently, this codebase is in a *semi-stable* state. I developed it as a tool to aid myself when refactoring, and simultaneously improving drastically the test quality and coverage of a service at work.

*ZZSpec is good at BDD* : This stimulates good, functional and behaviour driven testing.

Testing a system becomes simpler and we can cover many more "real" edge cases.

ZZSpec is written in a manner to ease higher level testing.


** Unit testing has its place (aided by property based)

Unit testing is an invaluable tool that should also be used in parallel to zzspec and other high level tests.
It is very easy to use, useful and gives also good information about a system.

Ideally, your "core domain" should be fully tested, and your "business logic" should be encoded in more pure code, ideally as data.

When relevant, you should leverage great property based testing tools and data generators.
E.g.  ZIO test, to ensure all edge cases are caught in tests.


** Dealing with dependencies

When we start using external dependencies in a system like databases, caches, external APIs, etc. You have 3 choices:

-   create and use mocks ‚òπÔ∏è
-   create and use stubs (dummy implementations) üòº
-   use real dependencies üëç

*Mocks are inherently evil* : Mocks are generally painful to write, read, debug and maintain.

They should be avoided when possible, we should use real implementations for most tests to a system.
testcontainers is a great library for this purpose, and we use it extensively.

Often mocks are used for lack of better tooling, or simply due to habit (specially if you have Java experience).
Lots of developers coming from a traditional enterprisy JDK environment know what we mean.

This tendency of doing one class per file, and creating tests for every single class and every single method along with extensive Mockito ideology.


** The cure

No marrying the test structure to code structure. No testing every individual class when not needed.
Ensure we test functionalities, almost never test how the code is written / implemented (this gives flexibility and *freedom to refactor*).

Attempt to test all ‚Äúuser paths‚Äù and possible interactions with the system, good and bad, low load high load, etc.
Write many unit tests and property based tests where it makes sense. Preferably auto-generated test cases, with a set of inputs.

** Pros ?

Easier and simpler tests of the entire system, tests have lower complexity. Easy to cover 100% of a ‚Äúuser flow‚Äù or a ‚Äúdata flow‚Äù.

Low chance of false positives (partly thanks to avoiding mocks too).
This allows for a good test-driven development approach, and more confidence in product.

Testers require less technical knowledge, programming or IT skills and do not need to learn all nitty gritty implementation details of the system.

More loose coupling from the code means more freedom of implementation + refactor



* Project management - Backlog

** Developing benchmarking capabilities (HTTP, Kafka, IO, Elastic, PostgreSQL)

** Use more of ZIO test and its data generators

** Make container layers more customizable

** Add Kafka Schema Registry container and Protobuf testing facilities

** Ensure the PostgreSQL DSL is more type safe

** Auto-generate and publish Scaladoc and documentation in Github Pages (with CI)

** Allow "initial state" in PostgreSQL and in Opensearch more easily


** Work done
*** DONE Auto-tag and publish artifacts to Maven (with CI)
CLOSED: [2024-09-14 za 14:05]
